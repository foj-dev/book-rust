<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Comments are used to document your code, making it more understandable for you and other developers. They
are ignored by the compiler, meaning they don't affect how your program runs, only its readability.</p>
<ul>
<li><strong>Clarity:</strong> use them to explain something complex or important.</li>
<li><strong>Maintenance:</strong> make it easier to work with your code in the future.</li>
<li><strong>Collaboration:</strong> create comments that are understandable to anyone.</li>
<li><strong>Debugging:</strong> temporarily disable a line or block of code for testing.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a single-line comment.

/*
  ...
  This is a multi-line comment.
  ...
*/
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="print"><a class="header" href="#print">Print</a></h2>
<p>The print! macro and its variations are used for debugging, informing the user, and generating formatted
output.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Prints text without a line break
print!("Hello,");
print!("world!");
print!("...");

println!("");

// Prints text with a line break
println!("Hello,");
println!("world!");
println!("...");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="line-break"><a class="header" href="#line-break">Line break</a></h2>
<p>Line breaks are used when you want to improve text formatting.</p>
<ul>
<li><strong>println!:</strong> used to print something and then move to a new line.</li>
<li><strong>\n:</strong> used to insert a new line character anywhere within the text.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// line break: \n
println!("What is your name?\nMy name is Rodolfo!");

println!("");

// It allows the visualization of (\n): \\n
println!("What is your name?\\nMy name is Rodolfo!");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="format"><a class="header" href="#format">Format</a></h2>
<p>The format! macro in Rust is used to improve data output formatting by using curly braces "{}" as placeho
lders that will be filled with the information.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//
let name = "Marcos";
println!("I'm, {}!", name);

//
let name = "Alice";
let years = 30;
println!("Hi, I'm {}, {} years old", name, years);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>⚠️</p>
<p><strong>For more information, see the <a href="https://doc.rust-lang.org/std/fmt/">Rust <code>std::fmt</code> documentation</a>.</strong></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>Variables are named spaces in memory that can hold a value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = "Roberto";
println!("What is your name: {}", name);

let num = 24;
println!("What number did you choose? {}", num);
<span class="boring">}</span></code></pre></pre>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>Once a variable's value is set, you cannot change it later. However, using "mut" after "let" makes the cr
eated variable mutable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//
let mut name = "Alice";
println!("What is your name: {}", name);

name = "Roberto";
println!("What is your name: {}\n", name);

//
let mut num = 24;
println!("Which number did you choose? {}", num);

num = 12;
println!("Which number did you choose? {}", num);
<span class="boring">}</span></code></pre></pre>
<h2 id="constant"><a class="header" href="#constant">Constant</a></h2>
<p>The constant is a variable with a fixed, immutable value, explicit type, and can be declared in any scope.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const POINTS: i32 = 3;
println!("{}", POINTS);
<span class="boring">}</span></code></pre></pre>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>You can declare a new variable with the same name as an existing one.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let food = "bread";
println!("{}", food);

let food = "milk";
println!("{}", food);

let food = "pizza";
println!("{}", food);
<span class="boring">}</span></code></pre></pre>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>Enclosing a block of code within curly braces {}, limits its functionality to that specific scope, while
still allowing access to previously defined data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;
println!("{}", x);

{
  let x = 2;
  println!("{}", x);
}

println!("{}", x);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>💡</p>
<p>Use the constant associated with the type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("u8: Min = {} | Max = {}", std::u8::MIN, std::u8::MAX);
println!("Usize: Min = {} | Max = {}", std::usize::MIN, std::usize::MAX);
<span class="boring">}</span></code></pre></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<p>Used for basic mathematical calculations.</p>
<ul>
<li>sum = +</li>
<li>subtraction = -</li>
<li>multiplication = *</li>
<li>division = /</li>
<li>remainder = %</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    println!("Sum: {}", 5 + 4);
    println!("Sub: {}", 5 - 2);
    println!("Mul: {}", 5 * 2);
    println!("Div: {}", 5.0 / 2.0);
    println!("Rem: {}", 5 % 2);
}</code></pre></pre>
<h2 id="precede-ordination"><a class="header" href="#precede-ordination">Precede ordination</a></h2>
<p>Some operators have priority over others</p>
<ul>
<li>( )</li>
<li>*, / and %</li>
<li>
<ul>
<li>and -</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Result: {}", 5 + 3 * 2);
println!("Result: {}", (5 + 3) * 2);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions---variables-constants-and-data-types"><a class="header" href="#questions---variables-constants-and-data-types">Questions - Variables Constants and Data Types</a></h1>
<hr />
<p>01 - How would you write a single-line comment in rust?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=fa5635f01f8529974ad29fcad714a6ff">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    // single-line comment
}</code></pre></pre>
  </details>
<p>02 - What is the syntax for a block comments in rust?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=9eef6021ef3fd0cda684697b68fb29a3">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    /* block comments */
}</code></pre></pre>
  </details>
<p>03 - Which macro would you use to print text on the same line, whihout adding a newline at the end?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=ffa6c6172b2088f36a0bb092c1d69afd">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    print!("Print: whihout adding a newline at the end!");
}</code></pre></pre>
  </details>
<p>04 - Which macro would you use to print text and automatically add a newline at the end?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=bbf1b87290e47b4d63762d07be948e7e">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    println!("Print: add newline at the end!");
}</code></pre></pre>
  </details>
<p>05 - How do you insert an explicit newline within a string that is being printed with println!?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=c18cc1eb489ca7399c8d797f6af9e6a5">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    println!("First\nSecond!");
}</code></pre></pre>
  </details>
<p>06 - What would be printed by the following code?</p>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    println!("First line\\nSecond line");
}</code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=f9933474d4f54c4c5c50167fcb9ffa06">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    println!("First line\\nSecond line");
}</code></pre></pre>
  </details>
<p>07 - What will be the output of the following code?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = "Ana";
let age = 30;
let text = format!("Hello, {}! You are {} years old.", name, age);
println!("{}", text);
<span class="boring">}</span></code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=66b53067454a20b107933a77820f0c42">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let name = "Ana";
    let age = 30;
    let text = format!("Hello, {}! You are {} years old.", name, age);
    println!("{}", text);
}</code></pre></pre>
  </details>
<p>08 - How would you use the format! macro to create the string "The value is: 42" from the number 42?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=1ed69cf700df24418c0c55c5cde8c4f4">Playground!</a></p>
 <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let number = 42;
    let formated = format!("The value is: {}", number);
    println!("{}", formated);
}</code></pre></pre>
 </details>
<p>09 - How can you format the number 7 so that it is displayer as "0007" using format!?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=0df831110a2b60915f120a25b1399c06">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let number: u8 = 7;
    println!("{:04}", number);

    //
    let formated = format!("{:04}", number);
    println!("{}", formated);
}</code></pre></pre>
  </details>
<p>10 - What is the utily of "{:?}" in the format! macro? Give an example of when you would use it.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=670868879cb54931c2ff8bf98de968a9">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let number: u8 = 1;
    println!("{:?}", number);
}</code></pre></pre>
  </details>
<p>11 - What does the specifier "{:#?}" do differently from "{:?}" when formatting a tuple or struct?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=b534638ecb6ea4cc4b269ae0802c1bfd">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let arr = (1, 2, 3, 4);

    //
    println!("{:#?}\n", arr);
    println!("{:?}", arr);
}</code></pre></pre>
  </details>
<p>12 - How do you declare a variable named score and assign in the value 100?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=487b3cbc4b51474715d196cf24a54899">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let score: u8 = 100;
    println!("Value: {}", score);
}</code></pre></pre>
  </details>
<p>13 - Write a line of code that declares a variable city with the value "Paris" and then prints it to the screen.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=b8fcb114295f9dc6b824778683735d34">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let city: &amp;str = "Paris";
    println!("City: {}!", city);
    println!("City: {:?}!", city);
}</code></pre></pre>
  </details>
<p>14 - Which keyword is used to declare a variable that can have its value changed after initialization?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=1d26ec751414229f76fad50bf10b45e2">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    // mut
}  </code></pre></pre>
  </details>
<p>15 - Declare a mutable variable named counter initialized with 0. Then, write the code to change the value of counter to 5 and print it.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=9d0dbd340798526b8af17861dac4c10f">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let mut counter: u8 = 0;
    println!("Counter = {:?}", counter);

    counter = 5;
    println!("Counter = {:?}", counter);
}</code></pre></pre>
  </details>
<p>16 - How do you declare a constant named MAX_SPEED with the value 9000 of type i32?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=9818b68a6204c70c9b9ff767ae640ccb">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">const MAX_SPEED: i32 = 9000;

fn main() {
    //
    println!("Max Speed: {:?}", MAX_SPEED);
}</code></pre></pre>
  </details>
<p>17 - Is it possible to change the value of a constant after its declaration?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=3e186423e1b02403a6489773539ab55d">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    // no
}</code></pre></pre>
  </details>
<p>18 - What is "shadowing" in Rust? Explain with a code example and what the output would be.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=aacfd95ca5035c54c55cc00cc5a35ef4">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let x: i8 = 0;
    {
      let x: f32 = 1.0;
      println!("{:?}", x);
    }
    println!("{:?}", x);
}</code></pre></pre>
  </details>
<p>19 - What will be the output of the following code?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;

let x = x + 1;
{
  let x = x * 2;
  println!("The inner value of x is: {}", x);
}

println!("The outer value of x is: {}", x);
<span class="boring">}</span></code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=29acc4265a22d22caa0e1e9c8ebec2a1">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let x = 5;
    let x = x + 1;
    {
      let x = x * 2;
      println!("The inner value of x is: {}", x);
    }

    println!("The outer value of x is: {}", x);
}</code></pre></pre>
  </details>
<p>20 - What will be the output of the following code? Explain why</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 10;
{
  let b = 20;
  println!("Inside the block: a = {}, b = {}", a, b);
}

// println!("Outside the block: a = {}, b = {}", a, b);
println!("Outside the block: a = {}", a);
<span class="boring">}</span></code></pre></pre>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=20123a0e1fb08faaaa95fbe669b38fd5">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let a = 10;
    {
      let b = 20;
      println!("Inside the block: a = {}, b = {}", a, b);
    }

    // println!("Outside the block: a = {}, b = {}", a, b);
    println!("Outside the block: a = {}", a);
}</code></pre></pre>
  </details>
<p>21 - What would happen if the commented line were uncommented and compiled?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=b0fb33a31ace400c7958947b73f2bca4">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    // fail to compile and produce a compile-time error.
}</code></pre></pre>
  </details>
<p>22 - What is the range of values that a u8 type can store?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=cc7a5ff024c87dceaa7364920ed84d5c">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    println!("u8: Max = {} and Min = {}", std::u8::MAX, std::u8::MIN);
}</code></pre></pre>
  </details>
<p>23 - What is the range of values that an i8 type can store?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=121241dc00402af3cba3f08f47996427">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    println!("i8: Max = {} and Min = {}", std::i8::MAX, std::i8::MIN);
}</code></pre></pre>
  </details>
<p>24 - How do you declare a variable maximum_age of type u16 with the value 150?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=960a6771cb88056c79bfcb5e29aa9fa8">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let maximum_age: u16 = 150;
    println!("maximum_age: {}", maximum_age);
}</code></pre></pre>
  </details>
<p>25 - How can you print the minimum and maximum values for the u32 type using its associated constants?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=fa9ce766e67a11d4b2ec3f63d7e0383d">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">const MAXIMUM: u32 = u32::MAX;
const MINIMUM: u32 = u32::MIN;

fn main() {
    //
    println!("Max = {}", MAXIMUM);
    println!("MIN = {}", MINIMUM);
}</code></pre></pre>
  </details>
<p>26 - Declare a variable named 'price' of type f32 with the value 19.99.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=e77d724638b13ea2ab70724acc9eb349">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust"> fn main() {
    //
    let price: f32 = 19.99;
    println!("Price = {}", price);
}  </code></pre></pre>
  </details>
<p>27 - Which of the types f32 or f64 offers greater precision?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=c0b536eb9115bacade017e9235e1390e">Playground!</a></p>
  <details>
   <summary>Answers</summary>
<ul>
<li><strong>f32 (single-precision floating-point):</strong> Uses 32 bits to represent a floating-point number. This allows for a certain level of precision, but it's less precise than f64;</li>
<li><strong>f64 (double-precision floating-point):</strong> Uses 64 bits to represent a floating-point number. The extra bits allow for a significantly larger range of representable numbers and, more importantly for this question, a much higher degree of precision in those representations.</li>
</ul>
  </details>
<p>28 - How do you declare a variable named 'initial' that stores the character 'P'?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=0aa9d42ef8dfde633e562d54d8488249">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let initial = 'P';
    println!("The initial is: {}", initial);
}</code></pre></pre>
  </details>
<p>29 - Can a char type in Rust store only ASCII characters? Explain.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=a2367bdb18135f5d79b06ecf3e0d75fa">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let cyrillic_char = 'Я';
    println!("Cyrillic character: {}", cyrillic_char);
}</code></pre></pre>
  </details>
<p>30 - Declare a variable named 'rain' and assign the value true to it.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=cc276fc9404a4321d32bbbe299ea0d56">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let rain: bool = true;
    println!("Rain? {}", rain);
}</code></pre></pre>
  </details>
<p>31 - What are the only two possible values for a variable of type bool?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=aed5d71ff42bf8d07364d18d6e26f644">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    // true and false
}</code></pre></pre>
  </details>
<p>32 - How do you declare a tuple named 'product' that stores an item's name (string), its quantity (integer), and its price (floating-point)? For example: ("Pe
n", 10, 1.50).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=a5bf6056eb8f5be1f01aa1d61b065536">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let product = ("Pen", 10, 1.50);
    println!("Product = {:?}", product);
}</code></pre></pre>
  </details>
<p>33 - Given the tuple 'let coordinates = (10, 20, 30);', how would you destructure this tuple into three separate variables x, y, and z?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=5fd94401acad8e2e5818b2d262e445b1">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let product: (&amp;str, u8, f32) = ("Pen", 10, 1.50);
    println!("Product: {}, {} and {}", product.0, product.1, product.2);

    //
    let (name, quantity, price): (&amp;str, u8, f32) = ("Pen", 10, 1.50);
    println!("Product: {}, {} and {}", name, quantity, price);

    //
    let (name, quantity, price) = product;
    println!("Product: {}, {} and {}", name, quantity, price);
}</code></pre></pre>
  </details>
<p>34 - How would you access the second element of the tuple 'let rgb = (255, 0, 128):'?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8c5e493c268b625e837a7ff63689eb77">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let product: (&amp;str, &amp;str, &amp;str) = ("Item 1", "Item 2", "Item 3");
    println!("Product: {}", product.1);

    //
    let (item_01, item_02, item_03) = product;
    println!("Product: {}", item_02);
}</code></pre></pre>
  </details>
<p>35 - Declare an array named 'notes' that can store 5 numbers of type f32. Initialize it with some values.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=20591a94ade8f226ee643ebdb4d37d82">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let notes: [u8; 5] = [1, 2, 3, 4, 5];
    println!("{:?}", notes);

    //
    let notes: [u8; 5];
    notes = [1, 2, 3, 4, 5];
    println!("{:?}", notes);

    //
    let notes_slice: &amp;[u8] = &amp;notes;
    println!("{:?}", notes_slice);

    //
    let partial_notes_slice: &amp;[u8] = &amp;notes[0..3];
    println!("{:?}", partial_notes_slice);
}</code></pre></pre>
  </details>
<p>36 - What is the main difference between an array and a tuple in terms of the data types they can store?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=97f67c372ff407555be540707a5df1bc">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<ul>
<li>
<p>Tuples ((T1, T2, ..., Tn)):</p>
<ul>
<li>Heterogeneous: Each element can have a different type (T1, T2, etc.);</li>
<li>Fixed Size: The number of elements is known at compile time and cannot change.</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let person_data: (&amp;str, i32, f64) = ("Alice", 30, 60.5);
let coordinates: (i32, i32) = (10, 20);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Arrays ([T; N]):</p>
<ul>
<li>Homogeneous: All elements must have the identical type T;</li>
<li>Fixed Size: The number of elements N is known at compile time and cannot change.</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers: [i32; 3] = [1, 2, 3];
let words: [&amp;str; 2] = ["hello", "world"];
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
  </details>
<p>37 - How would you access the first element of the array: let cores = ["red", "green", "blue"];?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=783ac15d71fa170ba5166fd884d9fdcb">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let list: [&amp;str; 3] = ["red", "green", "blue"];
    println!("List: {:?}", list);

    //
    let list: [&amp;str; 3] = ["red", "green", "blue"];
    println!("List: {:?}", list[0]);
}</code></pre></pre>
  </details>
<p>38 - What is the result of the expression 10 % 3?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=7d3fdc6c7c4879c3854fbaa87d9f910f">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    println!("{}", 10 % 3);
}</code></pre></pre>
  </details>
<p>39 - What is the result of the expression 5.0 / 2.0?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=90ff979dab835a73d3d0af9376e0f359">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    println!("{}", 5.0 / 2.0);
}</code></pre></pre>
  </details>
<p>40 - What will be the result of the following expression in Rust, and why? println!("{}", 20 - 5 * 2);</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=3dc47883e25713d88cec14a9d35d0dde">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    println!("{}", 20 - 5 * 2);
}</code></pre></pre>
  </details>
<p>41 - What will be the result of the following expression in Rust, and why? println!("{}", (20 - 5) * 2);</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8c121f9ed99c9fae2097aaea52290c79">Playground!</a></p>
  <details>
    <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    println!("{}", (20 - 5) * 2);
}</code></pre></pre>
  </details>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="u-unsigned-integers"><a class="header" href="#u-unsigned-integers">u: unsigned integers</a></h2>
<p>Whole numbers that can only be positive.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// u8 = 0 - 255
let number_u8: u8 = 255;
println!("{}", number_u8);

// u16 = 0 - 65.535
let number_u16: u16 = 255;
println!("{}", number_u16);

// u32 = 0 - 4.294.967.295
let number_u32: u32 = 255;
println!("{}", number_u32);

// u64 = 0 - 18.446.744.073.709.551.615
let number_u64: u64 = 255;
println!("{}", number_u64);

// u128 = 0 - ...
let number_u128: u128 = 255;
println!("{}", number_u128);
<span class="boring">}</span></code></pre></pre>
<h2 id="i-signed-integers"><a class="header" href="#i-signed-integers">i: signed integers</a></h2>
<p>Whole numbers that can be either positive or negative.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// i8 = -128 - 127
let number_i8: i8 =  127;
println!("{}", number_i8);

// i16 = -32.768 - 32.767 (-32_768 até 32_767)
let number_i16: i16 =  127;
println!("{}", number_i16);

// i32 = -2.147.483.648 - 2.147.483.647
let number_i32: i32 =  127;
println!("{}", number_i32);

// i64 = -9.223.372.036.854.775.808 - 9.223.372.036.854.775.807
let number_i64: i64 =  127;
println!("{}", number_i64);

// i128 =  ... and ...
let number_i128: i128 =  127;
println!("{}", number_i128);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="f-32-and-f64-floating-point-numbers"><a class="header" href="#f-32-and-f64-floating-point-numbers">f (32 and f64): floating-point numbers</a></h2>
<p>Numbers that have a decimal point.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// f32 = -3.4e+38 to +3.4e+38
let number_f32: f32 =  179.76;
println!("{}", number_f32);

// f64 = -1.8e+308 to +1.8e+308
let number_f64: f64 =  179.76;
println!("{}", number_f64);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="bool-boolean"><a class="header" href="#bool-boolean">bool: boolean</a></h2>
<p>Represents only two types of values: true or false.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//
let checked: bool = true;
println!("The data was checked? {}", checked);

//
let checked: bool = false;
println!("The data was checked? {}", checked);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="char-character"><a class="header" href="#char-character">char: character</a></h2>
<p>Used to represent a single character and requires the use of single quotes (e.g., 'a').</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//
let character: char = 'a';
println!("{}", character);

//
let symbol: char = ' ';
println!("{}", symbol);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tuples"><a class="header" href="#tuples">tuples</a></h2>
<p>Store multiple data items of different types in a fixed-size structure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data_types = ("a", 1);
println!("{:?}", data_types);

//
let data_types = ("b", 2);
println!("{:#?}", data_types);

//
let data_types : (char, u8);
data_types = ('c', 3);
println!("{:?}", data_types);

//
let (name, num) : (&amp;str, i8);
(name, num) = ("Alice", 4);
println!("{} and {}", name, num);

//
let (letter, yes) : (char, bool) = ('d', true);
let test =  (letter, yes);
println!("{:?}", test);

//
let person = ("Gregor", 64, 1.82);
let (x, y, z) = person;
println!("My name is {x}, i'm {y} years old and my height is {z}");
<span class="boring">}</span></code></pre></pre>
<h2 id="tuples-and-mut"><a class="header" href="#tuples-and-mut">tuples and mut</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//
let mut person = ("Roberto", 90, 1.98);
println!("{:#?}", person);

person.0 = "Moana";
person.1 = 58;
person.2 = 1.62;
println!("{:#?}", person);

//
let mut person = ("Helena", 67, 2.10);
println!("{:?}", person);

person.0 = "Arle";
person.1 = 64;
person.2 = 1.71;
println!("{:?}", person);

//
let (name, weight, height) = person;
println!("Name: {} \nWeight: {} \nHeight: {}", name, weight, height);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="array"><a class="header" href="#array">Array</a></h2>
<p>A list of data items that are all of the same type and have a fixed size.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//
let list: [u8; 4] = [1, 2, 3 , 4];
println!("{:?}", list);

//
let list: [u8; 4] = [1, 2, 3 , 4];
println!("{:#?}", list);

//
let list = ['a', 'b', 'c' , 'd'];
println!("{:?}", list);

//
let list: [&amp;str; 3];
list = ["ab", "cd", "de"];
println!("{:?}", list);

//
let [a, b, c]: [&amp;str; 3] = ["xy", "yz", "zw"];
let list = [a, b, c];
println!("{:?}", list);

//
let list = ["12", "23", "34"];
let [a, b, c] = list;
println!("{:?} {:?} {:?}", a, b, c);
<span class="boring">}</span></code></pre></pre>
<h2 id="array-and-mut"><a class="header" href="#array-and-mut">Array and mut</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//
let mut number: [i32; 5] = [10, 20, 30, 40, 50];
println!("{:?}", number);

number[0] = 100;
number[2] = 300;
println!("{:?}", number);

//
let mut names: [&amp;str; 3] = ["Alice", "Bob", "Charlie"];
println!("{:?}", names);

names[0] = "Ane";
names[1] = "Bren";
println!("{:?}", names);

//
let mut scores: [u8; 4];
scores = [80, 40, 90, 73];

let [s1, s2, s3, s4] = scores;
println!("{}, {}, {} and {}", s1, s2, s3, s4);

scores[2] = 85;
println!("{:?}", scores);
println!("{}", s3);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="questions---data-structures"><a class="header" href="#questions---data-structures">Questions - Data Structures</a></h1>
<hr />
<p>01 - Declare a variable positive_only of type u32 with the value 100. Declare another variable can_be_negative of type i32 with the value -100. Print both. Now, try to assign -5 to the positive_only variable. What happens when you try to compile and why?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=60ee836e6ff396e3ac5a69bbb0e00927">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let positive_only: u32 = 100;
    println!("{:?}", positive_only);

    //
    let can_be_negative: i32 = -100;
    println!("{:?}", can_be_negative);

    // error: attempt to compute `u8::MAX + 1_u8`, which would overflow
    // let positive_only: u32 = -5;
    // println!("{:?}", positive_only);
}    </code></pre></pre>
  </details>
<p>02 - Write Rust code to declare a variable max_u8 of type u8 and assign it the largest possible value for this type. Print this value. Then, in your code, try to assign max_u8 + 1 to a new u8 variable. What happens during compilation or execution (especially in debug vs. release mode, if you know)?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=6274ca481f8f0fd52a451f05a82a61b4">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let max_u8: u8 = u8::MAX;
    println!("{:?}", max_u8);

    // error: attempt to compute `u8::MAX + 1_u8`, which would overflow
    // let max_u8: u8 = u8::MAX + 1;
    // println!("{:?}");
}</code></pre></pre>
  </details>  
<p>03 - Declare a variable named world_population of type u64 and assign it the value 7800000000. Then, print the variable's value formatted with thousand separators (research how to do this if necessary, or just print the number).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=832da0159cb82e6a068efd9b923b24f0">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let world_population: u64 = 7_800_000_000;
    println!("World Population: {world_population:?}");
}</code></pre></pre>
  </details>  
<p>04 - Suppose you are modeling a system that uses extremely large unique IDs that will never be negative. Declare a variable super_large_id of type u128 and assign it the value 250000000000000000000000000000000000000 (25 followed by 36 zeros). Print this variable.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=3a8862c672f6d93355f4e6b2f78258f2">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let super_large_id: u128 = 250_000_000_000_000_000_000_000_000_000_000_000_000;
    println!("{:?}", super_large_id);
}

/*
    Debugging: The code below attempts to assign a value that exceeds the limit of i32. Correct the code by choosing a larger i type that can accommodate the value 2_200_000_000.

    fn main() {
        let large_positive: i32 = 2_200_000_000; // Exceeds the limit of i32
        println!("{}", large_positive);
    }
*/

// the literal `2_200_000_000` does not fit into the type `i32` whose range is `-2147483648..=2147483647`</code></pre></pre>
  </details>  
<p>05 - You need to store the number of video views, which can reach billions but will never be negative. Choose the most appropriate unsigned type (u32 or u64). Declare a variable video_views with this type, assign 2500000000 to it, and print.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=133cef87057e36e26a2df2b2b0b91765">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let video_views: u64 = 2_500_000_000;
    println!("{:?}", video_views);
}</code></pre></pre>
  </details>  
<p>06 - Declare two variables, min_val_i8 and max_val_i8, both of type i8. Assign them the smallest an largest possible value, respectively, for the i8 type. Print both values.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=ba79725b1daeebae28b1f8eff37f3ef6">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let min_val_i8: i8 = i8::MIN;
    println!("{:?}", min_val_i8);

    //
    let max_val_i8: i8 = i8::MAX;
    println!("{:?}", max_val_i8);
}</code></pre></pre>
  </details>  
<p>07 - Declare a variable named current_altitude_change of type i16 to represent an altitude change in meters. Assign it the value -350 (a descent of 350 meters). Print this value.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=e2634beea3fd8c7958ad78107fdccf0c">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let current_altitude_change: i16 = -350;
    println!("Altitude: {:?} meters", current_altitude_change);
}</code></pre></pre>
  </details>  
<p>08 - You are processing financial transactions where the values can be very large and represent both credits and debits (in cents, to avoid floating-point issues). Declare a variable transaction_value_cents of type i64 and assign it a value like -12345678900 (representing a debit of over 123million). Print it.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=3fbd70f6487531637264b9ee3280ea1d">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let transaction_value_cents: i64 = -123_456_789_000;
    println!("Debit = {:.3} million", transaction_value_cents);
}

/*
    Debugging: The code below attempts to assign a value that exceeds the limit of i32. Correct the code by choosing a larger i type that can accommodate the value 2_200_000_000.

    fn main() {
        let large_positive: i32 = 2_200_000_000; // Exceeds the limit of i32 println!("{}", large_positive);
    }
*/

// the literal `2_200_000_000` does not fit into the type `i32` whose range is `-2147483648..=2147483647`</code></pre></pre>
  </details>  
<p>09 - Declare a variable value_a of type i8 with 120. Declare value_b of type u8 with 120. Now, try to declare value_c of type i8 with -10 and value_d of type u8 attempting to assign -10 (literally). What happens to value_d during compilation? Explain.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=d4a06055b3c5af0c8761fed7b89da839">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let value_a: i8 = 120;
    println!("{:?}", value_a);

    //
    let value_b: u8 = 120;
    println!("{:?}", value_b);

    //
    let value_c: i8 = -10;
    println!("{:?}", value_c);

    //
    let value_d = -10;
    println!("{:?}", value_d);
}</code></pre></pre>
  </details>  
<p>10 - Write a code snippet that declares two variables score_team_a and score_team_b (both i32). Assign values to them and calculate the score_difference (which can be negative). Print the difference.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=fa61758c7b217653ce8e3963b6b33eb3">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let score_team_a: i32;
    let score_team_b: i32;

    //
    score_team_a = 20;
    score_team_b = 24;

    //
    let score_difference = score_team_a - score_team_b;
    println!("Score difference: {:?}", score_difference);
}</code></pre></pre>
  </details>  
<p>11 - Declare a variable ratio_f32 of type f32 with the value 2.0 / 7.0. Declare another variable ratio_f64 of type f64 with the same value 2.0 / 7.0. Print both using println!("{:.18}", variable_name); to show several decimal places. Compare the printed results.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=040c8c98e78c386078bef987a65b03be">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let ratio_f32: f32 = 2.0 / 7.0;
    let ratio_f64: f64 = 2.0 / 7.0;

    //
    println!("{:?}", ratio_f32);
    println!("{:?}", ratio_f64);
}

// 0.2857143
// 0.2857142857142857

fn main() {
    //
    let ratio_f32: f32 = 2.0 / 7.0;
    let ratio_f64: f64 = 2.0 / 7.0;

    //
    println!("{:.18}", ratio_f32);
    println!("{:.18}", ratio_f64);
}

// 0.285714298486709595
// 0.285714285714285698</code></pre></pre>
  </details>  
<p>12 - Declare a variable precise_measurement of type f64 with the value 123.456789123456. Print it.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=9ccc624dcf4dcde8ba60cad9cd694932">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let precise_measurement: f64 = 123.456_789_123_456;
    println!("{:?}", precise_measurement);
}</code></pre></pre>
  </details>  
<p>13 - Declare a variable gravity_force with the value 9.80665 without specifying the type, letting Rust infer it. Then, use std::any::type_name_of_val(&amp;gravity_force) to print the inferred type. What is printed and why?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=4c0396a98e0a06d4247ea9b5cfe5d34b">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let gravity_force = 9.80665;
    println!("{:?}", std::any::type_name_of_val(&amp;gravity_force));

    //
    let gravity_force: f32 = 9.80665;
    println!("{:?}", gravity_force);
    println!("{:?}", std::any::type_name_of_val(&amp;gravity_force));
}</code></pre></pre>
  </details>  
<p>15 - In an embedded system with limited memory, you need to store a sensor reading that ranges from -10.0 to +10.0 with two decimal places of precision. Declare a variable sensor_reading using f32 and assign 7.89. Print it. Justify why f32 might be suitable here.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=a42032c341e71ba8e776fdec44592f51">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let limited_memory: f32 = 10.00;
    println!("{:?}", limited_memory);

    //
    let limited_memory: f32 = -10.00;
    println!("{:?}", limited_memory);

    //
    let sensor_reading: f32 = 7.89;
    println!("{:?}", sensor_reading);
}</code></pre></pre>
  </details>  
<p>16 - Declare a character char_ascii = 'Z'; and a Unicode character char_unicode = 'Ω'; (Greek letter Omega). Use std::mem::size_of_val(&amp;char_ascii) and std::mem::size_of_val(&amp;char_unicode) to print the size in bytes of each. What do you observe?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=f9e7bfb04bce6059ef65d775c6a47bed">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let char_ascii: char = 'Z';
    println!("{:?}", char_ascii);

    //
    //let char_unicode: char = ' ';
    //println!("{:?}", char_unicode);

    //
    let char_unicode: char = 'Ω';
    println!("{:?}", char_unicode);

    //
    println!("{:?}", std::mem::size_of_val(&amp;char_ascii));
    println!("{:?}", std::mem::size_of_val(&amp;char_unicode));
}</code></pre></pre>
  </details>  
<p>17 - Declare a variable my_initial of type char and assign it the first letter of your name. Print it.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=a5ff5a70e060980ad52a8efa53d4a03b">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let my_ini: char = 'f';
    let my_init: char = 'o';
    let my_initi: char = 'j';

    //
    println!("{}{}{}", my_ini, my_init, my_initi);
}</code></pre></pre>
  </details>  
<p>18 - Declare three char variables: emoji_char with '😊', math_symbol with '∑', and arrow_char with '→'. Print all of them.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=30486e7e3a0fdc86a2ec84adda9a9140">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let emoji_char: char = '😊';
    let math_symbol: char = '∑';
    let arrow_char: char = '→';

    //
    println!("{}\n{}\n{}", emoji_char, math_symbol, arrow_char);
}</code></pre></pre>
  </details>  
<p>19 - Try to declare a char variable with more than one character, for example: let not_a_char: char = 'ab';. What happens when you try to compile?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=45efd1bdc0da80b32f1543e839e98faa">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // syntax Error: Literal must be one character long
    let not_a_char : char = 'ab';
}</code></pre></pre>
  </details>  
<p>20 - Declare a variable is_file_loaded and assign it true. Declare has_errors and assign false. Print both. Then, try to assign the integer 1 to a boolean variable. What does the Rust compiler say?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=df1360079b5d4efb448a2d3cff84f6cd">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let is_fiele_loaded: bool = true;
    println!("{:?}", is_fiele_loaded);

    //
    let has_errors: bool = false;
    println!("{:?}", has_errors);

    // mismatched types  expected `bool`, found integer
    // let assing: bool = 1;
    // println!("{:?}", assing);
}</code></pre></pre>
  </details>  
<p>22 - Declare is_online = true and has_new_messages = false. Create a variable should_notify that is true if is_online AND has_new_messages are both true. Print should_notify. Then, change has_new_messages to true and recalculate/print should_notify.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=ace1e16773e2f3777430517cf39dc8df">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let is_online: bool = true;
    let mut has_new_messages: bool = false;

    //
    let should_notify = is_online &amp;&amp; has_new_messages;
    println!("Should notify (initial): {}", should_notify);

    //
    has_new_messages = true;
    let should_notify = is_online &amp;&amp; has_new_messages;
    println!("Should notify (after new message): {}", should_notify);
}</code></pre></pre>
  </details>  
<p>23 - Create a tuple record that contains a name (&amp;str), an age (u8), and a passing grade (f32). For example: ("Maria", 22, 7.5). Print the entire tuple.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=d2aa6a5fe5a2c228a0c4cdf01a986637">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let record: (&amp;str, u8, f32) = ("Maria", 22, 7.5);
    println!("{:#?}", record);
}</code></pre></pre>
  </details>  
<p>24 - Create a tuple called server_response that contains an HTTP status code (u16) and a response message (&amp;str), such as (404, "Not Found"). Print the tuple.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=b2df2d26c5e24946753e76295327c42e">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let server_response: (u16, &amp;str) = (404, "Not Found");
    println!("{:?}", server_response);
}</code></pre></pre>
  </details>  
<p>25 - Given the tuple let product_info = ("Laptop XPTO", 1250.99, 15); (name, price, quantity in stock), access and print the product price and the quantity in stock using tuple indexing (e.g., product_info.1).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=9f27f40f83d95ebebb192508b357c23f">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let product_info: (&amp;str, f32, u16) = ("Laptop XPTO", 1.250_000, 15);
    let (name, price, quantity_and_stock) = product_info;

    //
    println!(
        "Product: {} \nQuantity and Stock: {}",
        product_info.0, product_info.2
    );

    //
    println!("{:#?}", product_info);

    //
    println!(
        "Product: {} \nPrice: {:.3} \nQuantity and Stock: {}",
        name, price, quantity_and_stock
    );
}</code></pre></pre>
  </details>  
<p>26 - Given the tuple let color_rgb = (255, 128, 0); (representing Orange), destructure it into the variables red, green, and blue. Print each variable separately.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=f50c766a98c72e95fbd4aaa7e3d3120a">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let color_rgb: (u8, u8, u8) = (255, 128, 0);
    let (red, green, blue) = color_rgb;

    //
    println!("Red: {} \nGreen: {} \nBlue: {}", red, green, blue);
}</code></pre></pre>
  </details>  
<p>27 - Create a tuple complex_data = ('X', vec![1,2,3], ("nested", true));. Print it. What does this demonstrate about the types a tuple can contain?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8f7d0587dddda6e1c6388e64ed55b20a">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let complex_data = ('X', vec![1, 2, 3], ("nested", true));
    println!("{:?}", complex_data);
    println!("{:?}", std::any::type_name_of_val(&amp;complex_data));
}</code></pre></pre>
  </details>  
<p>28 - Declare a tuple api_result with a boolean indicating success, a u64 for an ID, and a String for a message. Ex: (true, 1234567890, String::from("Successful operation")). Print using {:#?}.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=b8880d9ebc342019b093dca67f56f9c2">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let api_result: (bool, u64, String) = (true, 1234567890, String::from("Successful operation"));
    println!("{:#?}", api_result);
}</code></pre></pre>
  </details>  
<p>29 - Declare a tuple let config = ("localhost", 8080);. Try to modify the second element to 8081 (e.g., config.1 = 8081;). What happens when compiling? Now, redeclare it as let mut config = ("localhost", 8080); and try the same modification. Print config.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=12452da20c411cf36530f1ee4e16e5ce">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // let config: (&amp;str, u16) = ("localhost", 8080);
    //println!("{:?}", config);
    //config.1 = 8180; // cannot assign to `config.1`, as `config` is not declared as mutable  cannot assign

    //
    let mut config: (&amp;str, u16) = ("localhost", 8080);
    println!("{:?}", config);

    config.1 = 8180;
    println!("{:?}", config);
}</code></pre></pre>
  </details>  
<p>30 - Declare a mutable tuple player_stats to store name (&amp;str), score (i32), and lives (u8). Initialize with ("Hero", 0, 3). Then, modify the score to 1500 and the lives to 2. Print the updated tuple.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=728088262a4b76b297ec133ab582d176">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let mut player_stats: (&amp;str, i32, u8) = ("Hero", 0, 3);
    println!("{:#?}", player_stats);

    //
    player_stats.1 = 1500;
    player_stats.2 = 2;
    println!("{:#?}", player_stats);
}</code></pre></pre>
  </details>  
<p>31 - Create a mutable tuple let mut point = (10.0, 20.0);. Modify the first element to 15.5 and the second to 25.0 using index access syntax. Imprint the tuple.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=56d79e590ba12fc230dfda7b382e1444">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let mut point: (f32, f32) = (10., 20.);
    println!("{:#?}", point);

    //
    point = (15.5, 25.);
    println!("{:#?}", point);
}</code></pre></pre>
  </details>  
<p>32 - Create a mutable tuple file_details containing file name (String), size (u64), and whether it's editable (bool). Initialize it. Then, modify the file name (appending "_v2" to the original name) and change the editable status. Print the tuple.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=6b5e3c0a5e0c5f98b6c0fb95a097ed66">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let file_details: (String, u64, bool) = (String::from("test.txt"), 127, true);
    println!("{:#?}", file_details);

    //
    let mut file_details_v2 = file_details;
    file_details_v2.0 = String::from("teste_v2.txt");
    file_details_v2.1 = 256;

    //
    println!("{:#?}", file_details_v2);
}</code></pre></pre>
  </details>  
<p>33 - Create an array temperatures that stores the following f32 temperature readings: [22.5, 23.1, 21.9, 22.8, 23.5]. Print the entire array. Try adding a &amp;str to this array. What happens?</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=69669f162999a4891e2330a098733e81">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let temperatures: [f32; 5] = [22.5, 23.1, 21.9, 22.8, 23.5];
    println!("{:#?}", temperatures);

    // expected `f32`, found `&amp;str`
    let array_test: [f32; 2] = [22.5, "Test"];
    println!("{:#?}", array_test);
}</code></pre></pre>
  </details>  
<p>34 - Declare an array months containing the names of the first three months of the year as string slices. Print the name of the second month (remember zero-basedindexing).</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=53a62f786fc4470c6e2b3dca6917b82e">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let months: [&amp;str; 3] = ["January", "February", "March"];
    println!("{:#?}", months);

    //
    println!("{:#?}", months[1])
}</code></pre></pre>
  </details>  
<p>35 - Declare an array powers_of_two of 6 elements of type u32. Initialize it with the values [1, 2, 4, 8, 16, 32]. Print the last element of the array using indexing.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=092ca765f10e5f1653747f806d02dd5a">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main() {
    //
    let powers_of_two: [u32; 6] = [1, 2, 4, 8, 16, 32];
    println!("{:?}, {:?}, {:?}", powers_of_two[3], powers_of_two[4], powers_of_two[5]);
}</code></pre></pre>
  </details>  
<p>36 - Declare an array grades with 5 u8 scores all initialized to the value 0 using the repetition syntax (e.g., [0; 5]). Print the array and its size using .len().</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=29c28a00e5a862741f1b53cc520fb50e">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let grades: [u8; 5] = [0; 5];
    println!("{:?}", grades);

    //
    println!("{:?}", grades.len());
}</code></pre></pre>
  </details>  
<p>37 - Declare an array let fixed_scores = [100, 90, 80];. Try to modify the second element to 95 (e.g., fixed_scores[1] = 95;). What happens? Now, declare it as let mut fixed_scores = [100, 90, 80];, make the modification, and print it.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=af8c4e2b513d6360eaa771836c3675c1">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let fixed_scores = [100, 90, 80];
    println!("{:?}", fixed_scores);

    // fixed_scores[1] = 95;
    // println!("{:?}", fixed_scores);

    //
    let mut fixed_scores = [10, 30, 60];
    println!("{:?}", fixed_scores);

    fixed_scores[1] = 0;
    println!("{:?}", fixed_scores);
}</code></pre></pre>
  </details>  
<p>38 - Declare a mutable array inventory_counts of 4 elements of type u16, initialized with [10, 25, 5, 30]. Modify the count of the first item to 12 and the thirdto 8. Print the updated array.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=6a12c6b14485e4d9bdef556132eee612">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let mut inventory_counts: [u8; 4] = [10, 25, 5, 30];

    //
    inventory_counts[0] = 12;
    inventory_counts[3] = 8;

    //
    println!("{:?}", inventory_counts);
}</code></pre></pre>
  </details>  
<p>39 - Create a mutable array active_services: [bool; 3] initialized as [true, false, true]. Modify the second service to true and the last to false. Print the array.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8be14543c295e538007025d9270d9005">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let mut active_services:[bool; 3] = [true, false, true];
    println!("{:?}", active_services);

    //
    active_services[1] = true;
    println!("{:?}", active_services);

    //
    println!("{:?}, {:?}", active_services[0], active_services[2]);
}</code></pre></pre>
  </details>  
<p>40 - Create a mutable array pixel_colors: [[u8; 3]; 2] to represent two pixels, each with R, G, B components. Initialize it as [[255, 0, 0], [0, 255, 0]] (one red pixel, one green). Modify the first pixel to be blue ([0, 0, 255]) and the second to be yellow ([255, 255, 0]). Print the pixel array.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=a7f882b0c2e13c1e6c15c743714d21e1">Playground!</a></p>
  <details>
  <summary>Answers</summary>
<pre><pre class="playground"><code class="language-rust">fn main () {
    //
    let mut pixel_colors: [[u8; 3]; 3] = [[255, 0, 0], [0, 255, 0], [0, 0, 255]];
    println!("{:?}", pixel_colors);

    //
    pixel_colors[0][1] = 255;
    println!("{:?}", pixel_colors);
}</code></pre></pre>
  </details>  
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="arithmetic-operators-1"><a class="header" href="#arithmetic-operators-1">arithmetic operators</a></h2>
<p>Used for basic mathematical calculations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// sum: +
let sum = 1 + 1;
println!("Sum = {:?}", sum);

// subtraction: -
let sub = 2 - 2;
println!("Sub = {:?}", sub);

// multiplication: *
let mul = 3 * 3;
println!("Mul = {:?}", mul);

// division: /
let div = 4 / 4;
println!("Div = {:?}", div);

// remainder: %
let rem = 5 % 5;
println!("Rem = {:?}", rem);

// print
println!("10 + 10 = {:?}", 10 + 10);

// let
let calc: u8 = 2 + 5;
println!("2 + 5 = {:?}", calc);

// let + let
let num_01: u8 = 4;
let num_02: u8 = 5;
println!("num_01 + num_02 = {:?}", num_01 * num_02);

// let + let + let
let num_01: u16 = 9;
let num_02: u16 = 9;

let result: u16 = num_01 / num_02;
println!("Result = {:?}", result);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="assignment-operators"><a class="header" href="#assignment-operators">assignment operators</a></h2>
<p>Used to assign values to variables.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//
let mut num: u8 = 10;

// addition and assignment: +=
num += 1;
println!("10 += 1 == {}", num);

// subtraction and assignment: -=
num -= 1;
println!("10 -= 1 == {}", num);

// multiplication and assignment: *=
num *= 2;
println!("10 *= 2 == {}", num);

// division and assignment: /=
num /= 3;
println!("20 /= 3 == {}", num);

// remainder and assignment: %=
num %= 4;
println!("6 %= 4 == {}", num);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="string-and-str"><a class="header" href="#string-and-str">string and &amp;str</a></h2>
<ul>
<li>
<p><strong>String:</strong> use String when you need owned text data. It's ideal for situations where you're creating text (e.g., from user input), concatenating strings, or when you need the text to have a lifetime controlled by you;</p>
</li>
<li>
<p><strong>&amp;str:</strong> use &amp;str when you need to borrow immutable text data. It's perfect for working with string literals (fixed text in the code), for taking a "slice" of an existing String, or when a function only needs to read the text without modifying it or taking ownership.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// &amp;str
let num_01: &amp;str = "1";
let num_02: &amp;str = "2";
println!("num_01 + num_02 = {:?}", num_01.to_owned() + num_02);

// string
let num_03: String = String::from("1");
let num_04: String = String::from("2");
println!("num_03 + num_04 = {:?}", num_03 + &amp;num_04);

// String + &amp;str
let part_01: &amp;str = "10";
let part_02: String = String::from("20");
println!("part_01 + part_02 = {}", part_01.to_owned() + &amp;part_02);

// String + &amp;str + let
let part_01: String = String::from("Hello, ");
let part_02: &amp;str = "World";

let result: String =  part_01 + part_02;
println!("Reseult = {}", result);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tuples-1"><a class="header" href="#tuples-1">tuples</a></h2>
<p>Store multiple data items of different types in a fixed-size structure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// tuple
let tup: (u8, u8) = (1, 4);
println!("Tup 0 + Tup 1 = {:?}", tup.0 + tup.1);

// tuple let
let tup: (u8, u8);
tup = (3, 8);
println!("Tup 0 + Tup 1 = {:?}", tup.0 + tup.1);

// tuple + tuple
let tup: ((u8, u8),(u8, u8)) = ((2, 4),(6, 16));
println!("Tup.0.0 + Tup.0.1 = {:?}", tup.0.0 + tup.0.1);
println!("Tup.1.0 + Tup.1.1 = {:?}", tup.1.0 + tup.1.1);
println!("Tup.0.0 + Tup.1.0 = {:?}", tup.0.0 + tup.1.0);
println!("Tup.0.1 + tup.1.1 = {:?}", tup.0.1 + tup.1.1);

// tuple + let + let
let tup_01: (u8, u8) = (1, 4);
let tup_02: (u8, u8) = (14, 9);

let result = tup_01.0 + tup_01.1 + tup_02.0 + tup_02.1;
println!("Result = {:?}", result);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="array-1"><a class="header" href="#array-1">array</a></h2>
<p>A list of data items that are all of the same type and have a fixed size.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// array
let arr: [u8; 2] = [1, 4];
println!("{:?}", arr[0] + arr[1]);

// array let
let arr: [u8; 2];
arr = [3, 8];
println!("{:?}", arr[0] + arr[1]);

// array + array
let arr: [[u8; 2]; 2] = [[2, 4], [6, 16]];
println!("arr[0][0] + arr[0][1] = {:?}", arr[0][0] + arr[0][1]);
println!("arr[1][0] + arr[1][1] = {:?}", arr[1][0] + arr[1][1]);
println!("arr[0][0] + arr[1][0] = {:?}", arr[0][0] + arr[1][0]);
println!("arr[0][1] + arr[1][1] = {:?}", arr[0][1] + arr[1][1]);

// array + let + let
let arr_01: [u8; 2] = [1, 4];
let arr_02: [u8; 2] = [14, 9];

let result = arr_01[0] + arr_01[1] + arr_02[0] + arr_02[1];
println!("{:?}", result);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="scope-1"><a class="header" href="#scope-1">scope</a></h2>
<p>Enclosing a block of code within curly braces {}, limits its functionality to that specific scope, while still allowing access to previously defined data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// scope
let scop_00: i8 = 2;
let scop_01: i8 = 2;

{
    let result: i8 = scop_00 + scop_01;
    println!("{:?}", result)
}

println!("{:?}", scop_00 + scop_01);
// println!("{:?}", result);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="precedence"><a class="header" href="#precedence">precedence</a></h2>
<p>The order in which operations are performed in an expression.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// () &gt; *, /, and % &gt; + and -
let preced: [i8; 2] = [5, 3];

//
println!("{:?}", preced[0] + preced[1] * preced[1]);

// ()
println!("{:?}", (preced[0] + preced[1]) * preced[1]);

// *, / and %
println!("{:?}", preced[0] * preced[1] / preced[1] % preced[1]);

// + and -
println!("{:?}", preced[0] + preced[1] - preced[0] + preced[0] * preced[0]);

//
println!("{:?}", ((preced[0] + preced[1]) - (preced[0] + preced[0]) * preced[0]));
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="logical"><a class="header" href="#logical">logical</a></h2>
<p>Relating to operations that combine or modify Boolean (true/false) values to produce a single Boolean result.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//
let t: bool = true;
let f: bool = false;

// &amp;&amp;
println!("{}", t &amp;&amp; t); // true AND true = true
println!("{}", f &amp;&amp; f); // false AND false = false
println!("{}", t &amp;&amp; f); // true AND false = false
println!("{}", f &amp;&amp; t); // false AND true = false

// ||
println!("{}", t || t); // true OR true = true
println!("{}", f || f); // false OR false = false
println!("{}", t || f); // true OR false = true
println!("{}", f || t); // false OR true = true

// !
println!("{}", !t); // true = false
println!("{}", !f); // false = true
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
